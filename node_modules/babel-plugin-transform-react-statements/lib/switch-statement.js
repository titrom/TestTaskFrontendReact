"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = function (path, options) {
    var node = path.node;

    var valueExpression = getValueExpression(node);
    var switchBody = { cases: [], defaultStatement: null };

    (0, _commonLib.getChildren)(node).forEach(getCases, { switchBody: switchBody, options: options });

    var argsNames = getArgsNames(switchBody.cases.length);
    var args = getArgs(valueExpression, switchBody.cases);

    var cases = switchBody.cases.map(toSwitchCase, argsNames);
    var switchStatement = t.switchStatement(argsNames[0], cases);
    var statements = [switchStatement];

    if (switchBody.defaultStatement) {
        statements.push(switchBody.defaultStatement);
    }

    var body = t.blockStatement(statements);
    var fn = t.functionExpression(null, argsNames, body);
    var memberExpression = t.memberExpression(fn, t.identifier("call"));
    var callExpression = t.callExpression(memberExpression, args);

    return (0, _commonLib.appendExpressions)([callExpression], path, options);
};

var _commonLib = require("./common-lib.js");

var t = require("babel-types");

var errors = {
    NO_SWITCH_VALUE: "NO_SWITCH_VALUE",
    VALUE_NOT_EXPRESSION: "VALUE_NOT_EXPRESSION",
    NO_CASE_VALUE: "NO_CASE_VALUE",
    INVALID_CHILD_NODE: "INVALID_CHILD_NODE"
};

function getValueExpression(node) {
    var attribute = getValueAttribute(node);

    if (!attribute) throw new Error(errors.NO_SWITCH_VALUE);

    var valueExpression = attribute.value;


    if (!t.isJSXExpressionContainer(valueExpression)) throw new Error(errors.VALUE_NOT_EXPRESSION);

    return valueExpression.expression;
}

function getCases(childNode) {
    if (!t.isJSXElement(childNode)) throw new Error(errors.INVALID_CHILD_NODE);

    var switchBody = this.switchBody,
        options = this.options;
    var tagName = childNode.openingElement.name.name;


    if (tagName == "Case") {
        var valueAttribute = getValueAttribute(childNode);

        if (!valueAttribute) throw new Error(errors.NO_CASE_VALUE);

        var valueSource = valueAttribute.value;


        var value = t.isJSXExpressionContainer(valueSource) ? valueSource.expression : valueSource;

        var children = (0, _commonLib.getChildren)(childNode);
        var element = (0, _commonLib.combineElements)(children, options);
        var statement = [t.returnStatement(toCorrectExpression(element))];

        switchBody.cases.push({ value: value, statement: statement });
    } else if (tagName == "Default") {
        var _children = (0, _commonLib.getChildren)(childNode);
        var _element = (0, _commonLib.combineElements)(_children, options);

        switchBody.defaultStatement = t.returnStatement(toCorrectExpression(_element));
    } else throw new Error(errors.INVALID_CHILD_NODE);
}

function getValueAttribute(jsxNode) {
    var attributes = jsxNode.openingElement.attributes;


    for (var i = 0, lim = attributes.length; i < lim; i++) {
        var attribute = attributes[i];

        if (attribute.name.name == "value") return attribute;
    }

    return null;
}

function toCorrectExpression(value) {
    if (t.isJSXElement(value)) return value;

    if (t.isJSXExpressionContainer(value)) {
        return value.expression;
    }

    if (t.isJSXEmptyExpression(value)) {
        return t.nullLiteral();
    }

    if (t.isJSXText(value)) {
        return t.stringLiteral(value.value);
    }

    return value;
}

function toSwitchCase(_ref, index) {
    var statement = _ref.statement;

    var argsNames = this;

    return t.switchCase(argsNames[index + 1], statement);
}

function getArgsNames(count) {
    var args = [t.identifier("value")];

    for (var i = 1; i <= count; i++) {
        args.push(t.identifier("case" + i));
    }return args;
}

function getArgs(valueArgument, cases) {
    return cases.reduce(toArgs, [t.thisExpression(), valueArgument]);
}

function toArgs(args, _ref2) {
    var value = _ref2.value;

    args.push(value);

    return args;
}