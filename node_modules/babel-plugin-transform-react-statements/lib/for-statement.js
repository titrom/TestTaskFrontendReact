"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.default = function (path, options) {
    var parameters = {
        itemIdentifier: null,
        iterableExpression: null,
        counter: "index",
        keyIs: options.keyIs || null
    };

    var node = path.node;
    var attributes = node.openingElement.attributes;


    attributes.forEach(setParameters, parameters);

    if (!parameters.iterableExpression) throw new Error(errors.IN_ATTR_MISSING);

    var iterableElement = (0, _commonLib.combineElements)((0, _commonLib.getChildren)(node), options);

    var itemIdentifier = t.identifier(parameters.itemIdentifier || "value");
    var argNames = [itemIdentifier, t.identifier(parameters.counter)];

    if (t.isJSXElement(iterableElement)) {
        if (parameters.keyIs && iterableElement.openingElement.attributes.every(hasNotKeyAttribure)) {
            var attributeName = t.jSXIdentifier("key");
            var attributeValue = t.memberExpression(itemIdentifier, t.identifier(parameters.keyIs));
            var attribute = t.jSXAttribute(attributeName, t.jSXExpressionContainer(attributeValue));

            iterableElement.openingElement.attributes.push(attribute);
        }

        if (!parameters.itemIdentifier) {
            var _attributes = iterableElement.openingElement.attributes;


            if (!_attributes.some(isAlreadyExists, itemIdentifier)) {
                var spread = t.jSXSpreadAttribute(itemIdentifier);

                iterableElement.openingElement.attributes.push(spread);
            }
        }
    } else if (t.isJSXExpressionContainer(iterableElement)) {
        iterableElement = iterableElement.expression;
    } else if (t.isJSXEmptyExpression(iterableElement)) {
        iterableElement = t.nullLiteral();
    } else if (t.isJSXText(iterableElement)) {
        iterableElement = t.stringLiteral(iterableElement.value);
    }

    var returnStatement = t.returnStatement(iterableElement);
    var body = t.blockStatement([returnStatement]);
    var fn = t.functionExpression(null, argNames, body);

    var expressions = [createArrayMapCallExpression(fn, parameters)];

    if (!path.parentPath.isJSXElement()) {
        var wrapper = options.wrapper || "<span />";

        if (wrapper.trim()[0] == "<") {
            var _expressions = expressions,
                _expressions2 = _slicedToArray(_expressions, 1),
                expression = _expressions2[0];

            expressions = [(0, _commonLib.wrapElement)(expression, wrapper)];
        }
    }

    (0, _commonLib.appendExpressions)(expressions, path, options);
};

var _commonLib = require("./common-lib.js");

var t = require("babel-types");

var errors = {
    IN_ATTR_MISSING: "\"in\" attribute is missing",
    CHILD_MUST_BE_AN_ELEMENT: "CHILD_MUST_BE_AN_ELEMENT",
    EACH_ATTR_NOT_STRING: "EACH_ATTR_NOT_STRING",
    IN_ATTR_NOT_EXPRESSION: "IN_ATTR_NOT_EXPRESSION",
    COUNTER_ATTR_NOT_STRING: "COUNTER_ATTR_NOT_STRING",
    KEY_ATTR_NOT_STRING: "KEY_ATTR_NOT_STRING"
};

;

function hasNotKeyAttribure(attribute) {
    return attribute.name.name != "key";
}

function createArrayMapCallExpression(fn, parameters) {
    var callee = "Array.prototype.map.call".split(".").reduce(toMemberExpression);
    var args = [parameters.iterableExpression, fn, t.thisExpression()];

    return t.callExpression(callee, args);
}

function toMemberExpression(expression, item) {
    if (typeof expression == "string") {
        return t.memberExpression(t.identifier(expression), t.identifier(item));
    }

    return t.memberExpression(expression, t.identifier(item));
}

function setParameters(attribute) {
    var attributeName = attribute.name.name;


    switch (attributeName) {
        case "each":
            this.itemIdentifier = getItemIdentifier(attribute);
            break;

        case "in":
            this.iterableExpression = getIterableExpression(attribute);
            break;

        case "counter":
            this.counter = getCounterValue(attribute);
            break;

        case "key-is":
            this.keyIs = getKeyValue(attribute);
            break;
    }
}

function getItemIdentifier(_ref) {
    var valueNode = _ref.value;

    if (!t.isStringLiteral(valueNode)) throw new Error(errors.EACH_ATTR_NOT_STRING);

    return valueNode.value;
}

function getIterableExpression(_ref2) {
    var valueNode = _ref2.value;

    if (!t.isJSXExpressionContainer(valueNode)) throw new Error(errors.IN_ATTR_NOT_EXPRESSION);

    return valueNode.expression;
}

function getCounterValue(_ref3) {
    var valueNode = _ref3.value;

    if (!t.isStringLiteral(valueNode)) throw new Error(errors.COUNTER_ATTR_NOT_STRING);

    return valueNode.value;
}

function getKeyValue(_ref4) {
    var valueNode = _ref4.value;

    if (!t.isStringLiteral(valueNode)) throw new Error(errors.KEY_ATTR_NOT_STRING);

    return valueNode.value;
}

function isAlreadyExists(attribute) {
    if (!t.isJSXSpreadAttribute(attribute)) return false;

    var identifier = attribute.argument;


    if (!t.isIdentifier(identifier)) return false;

    return identifier.name == this.name;
}