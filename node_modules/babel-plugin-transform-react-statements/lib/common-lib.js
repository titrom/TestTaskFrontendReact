"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.appendExpressions = appendExpressions;
exports.combineElements = combineElements;
exports.wrapElement = wrapElement;
exports.getChildren = getChildren;

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var babel = require("babel-core");
var t = require("babel-types");

var errors = {
    WRAPPER_PARSE_ERROR: "incorrect \"wrapper\" parameter",
    NO_WRAP_ERROR: "elements must be wrapped in React.Component",
    WRAP_INVALID_TYPE: "WRAP_INVALID_TYPE"
};

function appendExpressions(expressions, path, options) {
    var parentPath = path.parentPath;

    if (parentPath.isJSXElement()) {
        var parentNode = parentPath.node;
        var openingElement = parentNode.openingElement,
            closingElement = parentNode.closingElement,
            children = parentNode.children;

        var isSelfClosing = closingElement == null;

        var items = expressions.map(toJSXExpression);
        var index = children.indexOf(path.node);

        children.splice.apply(children, [index, 1].concat(_toConsumableArray(items)));

        var newParentPath = t.jSXElement(openingElement, closingElement, children, isSelfClosing);

        parentPath.replaceWith(newParentPath);
    } else {
        if (expressions.length == 1) {
            var _expressions = _slicedToArray(expressions, 1),
                expression = _expressions[0];

            path.replaceWith(t.expressionStatement(expression));
        } else {
            var jsxExpressions = expressions.map(toJSXExpression);
            var wrapper = combineElements(jsxExpressions, options);

            path.replaceWith(wrapper);
        }
    }
}

function toJSXExpression(expression) {
    return t.jSXExpressionContainer(expression);
}

function combineElements(elements, options) {
    if (options.wrapper == "no-wrap") {
        if (elements.length != 1) throw new Error(errors.NO_WRAP_ERROR);
    }

    if (elements.length == 1) return elements[0];

    var wrapper = options.wrapper || "<span />";

    if (wrapper == "array-supported") {
        return t.arrayExpression(elements.reduce(toJSExpression, []));
    }

    try {
        var _babel$transform = babel.transform(wrapper, { plugins: ["syntax-jsx"] }),
            ast = _babel$transform.ast;

        var _ast$program$body = _slicedToArray(ast.program.body, 1),
            expressionStatement = _ast$program$body[0];

        if (!t.isExpressionStatement(expressionStatement)) throw null;

        var wrapperASTSource = expressionStatement.expression;

        if (!t.isJSXElement(wrapperASTSource)) throw null;

        var openingElementSource = wrapperASTSource.openingElement;
        var tagIdentifier = openingElementSource.name;


        var openingElement = t.jSXOpeningElement(tagIdentifier, openingElementSource.attributes);
        var closingElement = t.jSXClosingElement(tagIdentifier);

        return t.jSXElement(openingElement, closingElement, elements, false);
    } catch (error) {
        throw new Error(errors.WRAPPER_PARSE_ERROR);
    }
}

function toJSExpression(expressions, node) {
    if (t.isJSXExpressionContainer(node)) {
        expressions.push(node.expression);
    } else if (t.isJSXText(node)) {
        var text = node.value.trim();

        if (text) {
            expressions.push(t.stringLiteral(text));
        }
    } else {
        expressions.push(node);
    }

    return expressions;
}

function wrapElement(element, wrapper) {
    if (t.isJSXElement(element)) return element;

    var childNode = null;

    if (isValidChildNode(element)) {
        childNode = element;
    } else {
        try {
            childNode = t.jSXExpressionContainer(element);
        } catch (error) {
            throw new Error(errors.WRAP_INVALID_TYPE);
        }
    }

    try {
        var _babel$transform2 = babel.transform(wrapper, { plugins: ["syntax-jsx"] }),
            ast = _babel$transform2.ast;

        var _ast$program$body2 = _slicedToArray(ast.program.body, 1),
            expressionStatement = _ast$program$body2[0];

        if (!t.isExpressionStatement(expressionStatement)) throw null;

        var wrapperASTSource = expressionStatement.expression;

        if (!t.isJSXElement(wrapperASTSource)) throw null;

        var openingElementSource = wrapperASTSource.openingElement;
        var tagIdentifier = openingElementSource.name,
            attributes = openingElementSource.attributes;


        var openingElement = t.jSXOpeningElement(tagIdentifier, attributes);
        var closingElement = t.jSXClosingElement(tagIdentifier);

        return t.jSXElement(openingElement, closingElement, [childNode], false);
    } catch (error) {
        throw new Error(errors.WRAPPER_PARSE_ERROR);
    }
}

function isValidChildNode(node) {
    return t.isJSXElement(node) || t.isJSXEmptyExpression(node) || t.isJSXExpressionContainer(node) || t.isJSXSpreadChild(node) || t.isJSXText(node);
}

function getChildren(node) {
    return node.children.reduce(toValidChildNodes, []);
}

function toValidChildNodes(children, node) {
    if (t.isJSXEmptyExpression(node)) return children;

    if (t.isJSXText(node)) {
        var value = node.value.trim();

        if (value) {
            var textNode = t.jSXText(value);

            children.push(textNode);
        }
    } else {
        children.push(node);
    }

    return children;
}